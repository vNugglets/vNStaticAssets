<html><head><title>VMUGDemoDays - PowerCLI Lab Guide</title>
<style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=lhDjYqiy3mZ0x6ROQEUoUw');ol{margin:0;padding:0}.c6{list-style-type:circle;margin:0;padding:0}.c15{max-width:648pt;background-color:#ffffff;padding:24pt 72pt 60pt 72pt}.c7{list-style-type:disc;margin:0;padding:0}.c4{color:#666666;font-size:12pt;font-weight:bold}.c12{color:inherit;text-decoration:inherit}.c11{color:#1155cc;text-decoration:underline}.c8{text-indent:36pt;margin-left:72pt}.c5{height:11pt}.c9{margin-left:72pt}.c3{padding-left:0pt}.c1{direction:ltr}.c13{text-indent:36pt}.c14{font-style:italic}.c2{margin-left:36pt}.c0{font-family:"Courier New"}.c10{font-family:"Consolas"}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#666666;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Arial";padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#666666;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:10pt;font-family:"Arial";padding-bottom:2pt}</style>
<style type="text/css">
/* code-face in text */
span.c0 {border-width: 1px 0px; border-style: dotted; border-color: #666699; background-color: #F9F9F9;}

/* code blocks */
P.c1.c2, P.c1.c13, P.c1.c8 {
	/* background-color: #012456; */
	background-color: #123578;
	color: #EEEDF0;
	font-family: 'Courier New',Consolas,'Lucida Console','Bitstream Vera Sans Mono','DejaVu Sans Mono',monospace;
	font-size: 10pt;
	line-height: normal;
	margin-top: 0px;
	margin-left: 24pt;
	padding-left: 5px;
	white-space: pre-wrap;
	word-wrap: break-word;
}

</style>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-6769502-1']);
  _gaq.push(['_setDomainName', 'vnugglets.com']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body class="c15"><h2 class="c1"><a name="h.pqqpd84uzv8f"></a><img height="20" src="images/image01.png" width="23"><span>PowerCLI 102 / 201 Lab Guide</span></h2><p class="c5 c1"><span></span></p><p class="c1"><span>Lab Layout:</span></p><p class="c1"><span>VDI client machine: &nbsp;Windows 7 with PowerShell and PowerCLI</span></p><p class="c1"><span>Passwords on lab items are generally &quot;vmware#1&quot;. &nbsp;To be explicit:</span></p><ol class="c7" start="1"><li class="c3 c1 c2"><span>vCenter server: &nbsp;vcenter; credentials: &nbsp;administrator, vmware#1</span></li><li class="c3 c1 c2"><span>ESXi hosts: &nbsp;esxi01, esxi02; credentials: &nbsp;root, vmware#1</span></li><li class="c3 c1 c2"><span>various VMs on the virtual ESXi hosts: &nbsp;linux-based are root, vmware#1</span></li><li class="c3 c1 c2"><span>DHCP/DNS machine -- access not needed</span></li></ol><p class="c5 c1"><span></span></p><p class="c1"><span>This lab covers a wide range of PowerCLI topics. &nbsp;It starts out with some basic, introductory-level pieces, and then moves on to some discussions of more involved uses of PowerCLI. &nbsp;The lab uses PowerCLI to perform reporting and operations on vSphere inventory items. &nbsp;Launch the vSphere client, if desired, to get your bearings in the lab environment, and possibly to watch as things/actions are made to happen via PowerCLI.</span></p><ol class="c7" start="1"><li class="c3 c1 c2"><span>The coding expectation of you during this lab: &nbsp;nearly all necessary code is presented in this lab guide. &nbsp;You can copy/paste the code into your PowerShell session to go through the lab. &nbsp;There are a few exceptions where you would need to adjust things for using different values or manually enter items, like new folder name of your choice, or for entering things like passwords.</span></li><li class="c3 c1 c2"><span>The PowerShell/PowerCLI code snippets to use are presented in indented text blocks.</span></li><li class="c3 c1 c2"><span>Note about thin provisioning: &nbsp;Throughout the lab, virtual disks are created as thin-provisioned. &nbsp;There are differing uses/opinions for thin provisioning virtual disks: &nbsp;this lab uses thin not as to endorse / recommend thin disks, just to keep datastore size lower.</span></li></ol><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><h2 class="c1"><a name="h.58kqbbbushy1"></a><img height="20" src="images/image01.png" width="23"><span>Module 0: &nbsp;Getting Started -- Let&#39;s Go!</span></h2><p class="c1"><span class="c4">Connect to the Windows 7 client machine</span></p><p class="c1"><span>Launch PowerShell (Start button -&gt; type &quot;PowerShell&quot; -&gt; click &quot;Windows PowerShell&quot;)</span></p><ol class="c7" start="1"><li class="c3 c1 c2"><span>For this lab, we will be using the standard PowerShell console, not the VMware PowerCLI console. &nbsp;This is partly to keep the session light/clean/standard, and to illustrate about PSSnapins. &nbsp;In the next step we add the core VMware PSSnapin needed.</span></li></ol><p class="c1"><span>Maximize the PowerShell window vertically (double-click on the top or bottom window border, or drag one of these borders up/down respectively)</span></p><ol class="c7" start="1"><li class="c3 c1 c2"><span>Rather than try to get value out of PowerCLI / PowerShell returns in an 80 x 25 window, go big. &nbsp;Personal preference comes into play here, but for this lab, go ahead, use the screen. &nbsp;Alright, enough of the telling you how to size your windows.</span></li></ol><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Add Main PowerCLI PSSnapin</span></p><p class="c1"><span>In PowerShell, add the main VMware PowerCLI PSSnapin that provides all of the excellent VMware cmdlets that we will be covering:</span></p><p class="c1 c2"><span>Add-PSSnapin VMware.VimAutomation.Core</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>(copy this line and paste it into the PowerShell session, or type it there)</span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Get Connected to vCenter</span></p><p class="c1"><span>Typically, one would use a domain account with vCenter permissions to connect to vCenter. &nbsp;In this lab, for the sake of keeping the environment small, we will be using an account local to the vCenter server. &nbsp;Create a </span><span class="c0">PSCredential</span><span>&nbsp;object with the vCenter administrator&#39;s credentials using the built-in PowerShell cmdlet </span><span class="c0">Get-Credential</span><span>&nbsp;(you will be prompted for password -- use the vCenter administrator account given at the start of this lab document):</span></p><p class="c1 c2"><span>$credVCAdmin = Get-Credential administrator</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Connect to the vCenter server using these credentials via </span><span class="c0">Connect-VIServer</span><span>, and have the cmdlet save the credentials for subsequent connections to the vCenter (by specifying the </span><span class="c0">-SaveCredentials</span><span>&nbsp;parameter):</span></p><p class="c1 c2"><span>Connect-VIServer vCenter -SaveCredentials -Credential $credVCAdmin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## ignore self-signed cert message</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>This set of credentials for this vCenter server is now stored in the local VI credential store. &nbsp;You can display the contents of the credential store using:</span></p><p class="c1 c2"><span>Get-VICredentialStoreItem</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Sample output:</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c10">Host &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;User &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c10">---- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;----</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c10">vCenter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;administrator</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Subsequent connections to the given vCenter will use the credentials from the VI credential store (if no credentials are passed at connect time). &nbsp;You can test by disconnecting then reconnecting to the vCenter server:</span></p><p class="c1 c2"><span>Disconnect-VIServer -Confirm:$false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## disconnect from the vCenter server</span></p><p class="c1 c2"><span>Connect-VIServer vCenter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## reconnect, without explicitly passing non-current-user credentials</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Handy. &nbsp;Sample output:</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c10">Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Port &nbsp;User</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c10">---- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---- &nbsp;----</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c10">vCenter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;443 &nbsp; administrator</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">An Informative PowerShell Window Title Bar</span></p><p class="c1"><img height="49" src="images/image09.png" width="800"></p><p class="c1"><span>The 5.0.1 release of PowerCLI changed the behavior of </span><span class="c0">Connect-VIServer</span><span>&nbsp;/ </span><span class="c0">Disconnect-VIServer</span><span>: &nbsp;no longer did these cmdlets update the title bar of the PowerShell / PowerCLI window to reflect the VI servers to which the PowerCLI session was connected. &nbsp;So, one could rely on the </span><span class="c0">$global:DefaultVIServers</span><span>&nbsp;variable to know to which VI servers the session is connected -- just echo out its value. &nbsp;Or, you can use a quick function to update the title bar (define this function in the current PowerShell session by pasting the below code into the session):</span></p><p class="c1 c2"><span>function Update-VNTitleBar() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## written by AC at vNugglets.com</span></p><p class="c1 c2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## check to see if there are any currently connected servers</span></p><p class="c1 c2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($global:DefaultVIServers.Count -gt 0) {</span></p><p class="c1 c2"><span>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## at least one connected server -- modify the window title variable accordingly</span></p><p class="c1 c13 c2"><span>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$strWindowTitle = &quot;[PowerCLI] Connected to {0} server{1}: &nbsp;{2}&quot; -f $global:DefaultVIServers.Count, `</span></p><p class="c1 c8"><span>$(if ($global:DefaultVIServers.Count -gt 1) {&quot;s&quot;}), (($global:DefaultVIServers | %{$_.Name}) -Join &quot;, &quot;)</span></p><p class="c1 c2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</span></p><p class="c1 c13 c2"><span>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## no connected servers, modify the window title variable to show &quot;not connected&quot;</span></p><p class="c1 c2"><span>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$strWindowTitle = &quot;[PowerCLI] Not Connected&quot;</span></p><p class="c1 c2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} ## end else</span></p><p class="c1 c2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## change the window title</span></p><p class="c1 c2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$host.ui.RawUI.WindowTitle = $strWindowTitle</span></p><p class="c1 c2"><span>} ## end fn</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Then, just call the function to update the PowerShell window title bar:</span></p><p class="c1 c2"><span>Update-VNTitleBar</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>You should see the title bar change to display info about the current vCenter connection.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Another option is to create a couple more functions to use in place of </span><span class="c0">Connect-</span><span>&nbsp;/ </span><span class="c0">Disconnect-VIServer</span><span>: &nbsp;one each that calls </span><span class="c0">Connect-</span><span>&nbsp;/ </span><span class="c0">Disconnect-VIServer</span><span>&nbsp;with the given params and then calls the </span><span class="c0">Update-TitleBar()</span><span>&nbsp;function. &nbsp;For now, we will just inspect the </span><span class="c0">$global:DefaultVIServers</span><span>&nbsp;or call </span><span class="c0">Update-VNTitleBar</span><span>&nbsp;if question arises, and leave the simple wrapper function creation as an exercise for you at another time.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><h2 class="c1"><a name="h.axs0sco6ljs4"></a><img height="20" src="images/image01.png" width="23"><span>Module 1: &nbsp;Info Gathering with PowerCLI</span></h2><p class="c1"><span>One of the many uses of PowerCLI is to gather info about inventory items in the virtual infrastructure. &nbsp;From VMs to VMHosts to Clusters to the vCenter service instance itself. &nbsp;This can be done using the standard cmdlets for each of these object types, like </span><span class="c0">Get-VM</span><span>&nbsp;or </span><span class="c0">Get-VMHost</span><span>. &nbsp;Another way is to use the </span><span class="c0">Get-View</span><span>&nbsp;cmdlet that deals with all sorts of inventory objects. &nbsp;While the </span><span class="c0">Get-View</span><span>&nbsp;route might become a bit more involved, it also allows for other gains, to be discussed later.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">VM virtual hardware version</span></p><p class="c1"><span>Let us start by getting some standard VM info, like the virtual hardware version:</span></p>
<p class="c1 c2"><span>## using Get-VM</span></p><p class="c1 c2"><span>Get-VM | Select-Object Name,Version</span></p><p class="c5 c1 c2"><span></span></p><p class="c1 c2"><span>## using Get-View</span></p><p class="c1 c2"><span>Get-View -ViewType VirtualMachine -Property Name, Config.Version | Select Name,@{n=&quot;HdwVersion&quot;; e={$_.Config.Version}}</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Both should return a set of selected objects with VM name and the virtual hardware version. &nbsp;With the small size of the lab environment, the speed difference is not as pronounced, but </span><span class="c0">Get-View</span><span>&nbsp;is the winner. &nbsp;The </span><span class="c0">Select-Object</span><span>&nbsp;statement in the </span><span class="c0">Get-View</span><span>&nbsp;version uses a simple calculated property to access a sub-property and present it as a property of the returned objects.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Configured Guest OS Version</span></p><p class="c1"><span>More than one way exists to get the guest OS information for a VM. &nbsp;A couple of ways: &nbsp;the VM configuration, as set at VM creation/clone time, and the actual guest OS info that is installed on the VM, which is reported per VMware Tools. &nbsp;The information about the configured guest OS is available in the </span><span class="c0">.Config</span><span>&nbsp;property of a </span><span class="c0">VirtualMachine</span><span>&nbsp;object. &nbsp;Tools-reported items about the guest are available in the </span><span class="c0">.Guest</span><span>&nbsp;property (but depend on VMware Tools to be running in each guest at the time of the query). &nbsp;Let us get the configured guest OS info for all VMs:</span></p><p class="c1 c2"><span>## using Get-VM</span></p><p class="c1 c2"><span>Get-VM | Select-Object Name, @{n=&quot;ConfigdGuestId&quot;; e={$_.ExtensionData.Config.GuestId}}, @{n=&quot;ConfigdGuestFullName&quot;; e={$_.ExtensionData.Config.GuestFullName}}</span></p><p class="c5 c1 c2"><span></span></p><p class="c1 c2"><span>## using Get-View</span></p><p class="c1 c2"><span>Get-View -ViewType VirtualMachine -Property Name, Config.GuestId, Config.GuestFullName | Select Name, @{n=&quot;ConfigdGuestId&quot;; e={$_.Config.GuestId}}, @{n=&quot;ConfigdGuestFullName&quot;; e={$_.Config.GuestFullName}}</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Here again, you see the use of calculated properties to access deeper properties of the given objects.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Comparing the results, you should see the same info, with the exception that the </span><span class="c0">Get-View</span><span>&nbsp;version has been written to include info about templates as well. &nbsp;Here the speed difference should be a bit more apparent, even in this small environment.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>The </span><span class="c0">.ExtensionData</span><span>&nbsp;property discussion is later in the lab.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">VMHost Versions</span></p><p class="c1"><img height="56" src="images/image06.png" width="475"></p><p class="c1"><span>Need to know what ESXi version your VMHosts are running? &nbsp;How about:</span></p><p class="c1 c2"><span>## using Get-VM</span></p><p class="c1 c2"><span>Get-VMHost | Select Name, Version, Build</span></p><p class="c5 c1 c2"><span></span></p><p class="c1 c2"><span>## using Get-View</span></p><p class="c1 c2"><span>Get-View -ViewType HostSystem -Property Name, Config.Product.Version, Config.Product.Build | Select Name, @{n=&quot;Version&quot;; e={$_.Config.Product.Version}}, @{n=&quot;Build&quot;; e={$_.Config.Product.Build}}</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>The output is the same between these two ways. &nbsp;The discussion about &quot;why bother with </span><span class="c0">Get-View</span><span>&quot; comes later in the lab.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Datastore Summaries</span></p><p class="c1"><img height="85" src="images/image08.png" width="604"></p><p class="c1"><span>Now to get some summary information about datastores in the environment. &nbsp;Say, maybe some capacity/usage details, along with the filesystem version:</span></p><p class="c1 c2"><span>Get-Datastore | Select Name, FileSystemVersion, CapacityGB, FreeSpaceGB, @{n=&quot;UncommittedGB&quot;; e={[Math]::Round($_.ExtensionData.Summary.Uncommitted / 1GB, 1)}}</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>The &quot;</span><span class="c0">UncommittedGB</span><span>&quot; calculated property gives the amount of storage that has been provisioned on the datastore and that has not yet been used or &quot;committed&quot; on that datastore. &nbsp;As in, the amount of thin-provisioned disk on the datastore that has not yet been used on the datastore.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">VM Size info (Number of vCPUs, Memory, Used Space)</span></p><p class="c1"><span>To get info about VMs and their configured resources, </span><span class="c0">Get-VM</span><span>&nbsp;returns objects with the right info needed. &nbsp;To do this for all VMs:</span></p><p class="c1 c2"><span>Get-VM | Select Name,NumCPU,MemoryMB,UsedSpaceGB</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>or, to get this info broken down by cluster:</span></p><p class="c1 c2"><span>Get-Cluster | Foreach-Object {$strClusterName = $_.Name; Get-VM -Location $_} | `</span></p><p class="c1 c2"><span>Select Name,NumCPU,MemoryMB,UsedSpaceGB,@{n=&quot;Cluster&quot;; e={$strClusterName}}</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>The second way uses the </span><span class="c0">-Location</span><span>&nbsp;parameter to </span><span class="c0">Get-VM</span><span>&nbsp;to narrow the search scope to just the given vSphere container (a cluster in this example). &nbsp;Very helpful when looking to group items by inventory location, or to focus the search (though, there is only one cluster in our test environment here).</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Pro Tip: &nbsp;And, you may notice these results being displayed in list format instead of table format. &nbsp;Not directly PowerCLI related, but to run a previous command in the PowerShell command history and pipe it to something else (say, to &quot;</span><span class="c0">Format-Table -AutoSize</span><span>&quot;), you can get the command ID of said previous command, then use it with </span><span class="c0">Invoke-History</span><span>. &nbsp;That is:</span></p><p class="c1 c2"><span>Get-History&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## display the last x commands; then, make note of the command ID</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>This returns something like:</span></p>
<p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c10">&nbsp; Id CommandLine</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c10">&nbsp; -- -----------</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c10">&nbsp; ...</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c10">&nbsp; 18 Get-VMHost | Select Name, Version, Build</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c10">&nbsp; 19 Get-View -ViewType HostSystem -Property Name, Config.Product.Version, Config.Product</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c10">&nbsp; 20 Get-Datastore | Select Name, FileSystemVersion, CapacityGB, FreeSpaceGB, @{n=&quot;Uncomm</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c10">&nbsp; 21 Get-Cluster | %{$strClusterName = $_.Name; Get-VM -Location $_} | Select Name,NumCPU</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c10">&nbsp; 22 Get-VM | Select Name,NumCPU,MemoryMB,UsedSpaceGB</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c10">&nbsp; 23 Get-Cluster | Foreach-Object {$strClusterName = $_.Name; Get-VM -Location $_} | `...</span></p><p class="c1"><span><BR /></span></p><p class="c1"><span>Then, you can run the item with history ID 23 again, and pass its results to the pipeline like:</span></p><p class="c1 c2"><span>Invoke-History 23 | Format-Table -AutoSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## where &quot;23&quot; is the ID of the command to run again</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Try these, substituting the history ID value returned from </span><span class="c0">Get-History</span><span>&nbsp;that corresponds with the command to run again.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><h2 class="c1"><a name="h.7uyuftwpu0hy"></a><img height="20" src="images/image01.png" width="23"><span>Module 2: &nbsp;Day to Day Operations with PowerCLI</span></h2><p class="c1"><span>Information gathering with PoweCLI is great. &nbsp;But, we need to do something to inventory items with PowerCLI. &nbsp;Let us act on the inventory items -- not just report about them.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Create New Inventory Folder and Move VM Into It</span></p><p class="c1 c2"><span>## create the folder in the root VM inventory folder (&quot;vm&quot;)<br>New-Folder -Location (Get-Folder vm) -Name TestFolder0</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>This creates a new VM inventory folder (a &quot;blue&quot; folder in the vSphere client). &nbsp;</span><span>The default root VM inventory folder per datacenter is named &quot;vm&quot;.</span><span>&nbsp; By specifying this &quot;vm&quot; folder as the value for the </span><span class="c0">-Location</span><span>&nbsp;parameter (and since we are only dealing with one datacenter right now), </span><span class="c0">New-Folder</span><span>&nbsp;creates the new folder in this default root VM folder. &nbsp;You can see in the vSphere client the &quot;Create folder&quot; recent task, and if you switch to the &quot;VMs and Templates&quot; view (keyboard shortcut &quot;CTRL + SHIFT + V&quot; in the vSphere client), you see a new, empty folder named &quot;TestFolder0&quot;. &nbsp;Now, to move some VMs:</span></p><p class="c1 c2"><span>## move a couple of VMs into this folder<br>Move-VM Win7*_empty -Destination (Get-Folder TestFolder0) -RunAsync</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>This second part uses the first positional parameter, which corresponds to </span><span class="c0">-VM</span><span>, to specify which VMs to move, a destination of the newly created folder, and runs asynchronously. &nbsp;This returns task info objects for each move task. &nbsp;The task of moving a VM to a new folder is pretty quick, but you can check task status using </span><span class="c0">Get-Task</span><span>. &nbsp;Viola! &nbsp;The command moved the targeted VMs to the destination inventory folder.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Create VMs From Template</span></p><p class="c1"><img height="103" src="images/image04.png" width="295"></p><p class="c1"><span>Time for several new VMs? &nbsp;Time for </span><span class="c0">New-VM</span><span>. &nbsp;A customer, Stymie, needs six (6) new Windows Server 2012 VMs. &nbsp;He provided a list of names for the new VMs:</span></p><ol class="c7" start="1"><li class="c3 c1 c2"><span>app-srv-03</span></li><li class="c1 c2 c3"><span>app-srv-04</span></li><li class="c3 c1 c2"><span>dc01</span></li><li class="c3 c1 c2"><span>dc02</span></li><li class="c3 c1 c2"><span>gtwy01</span></li><li class="c3 c1 c2"><span>webprint01</span></li></ol><p class="c5 c1"><span></span></p><p class="c1"><span>Since there is a Windows Server 2012 template in the inventory, you can use the </span><span class="c0">-Template</span><span>&nbsp;parameter of </span><span class="c0">New-VM</span><span>. &nbsp;Using the list of VM names, use a </span><span class="c0">Foreach-Object</span><span>&nbsp;loop to call </span><span class="c0">New-VM</span><span>&nbsp;to deploy a new VM from the given template for each of the new VMs-to-be:</span></p><p class="c1 c2"><span>## create six new VMs by the given names from template</span></p><p class="c1 c2"><span>&quot;dc01,dc02,app-srv-03,app-srv-04,webprint01,gtwy01&quot;.Split(&quot;,&quot;) | %{New-VM -Name $_ -Template Win2012Tmpl -Location OtherMachines -VMHost (Get-Cluster Lab | Get-VMHost | Get-Random) -DiskStorageFormat Thin -Description &quot;for Stymie, ticket 332421&quot; -RunAsync}</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>The comma-separated VM name string is split up into separate strings using the String class method </span><span class="c0">Split()</span><span>. &nbsp;The </span><span class="c0">New-VM</span><span>&nbsp;cmdlet then creates a new VM for each VM name, places them in the &quot;OtherMachines&quot; inventory folder, places them on random hosts in the given cluster, and lets the operations run asynchronously, so as to kick off all of the new VM creations at [about] the same time.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Alright, six new VMs, as requested. &nbsp;You can get their info with a:</span></p><p class="c1 c2"><span>Get-VM dc01,dc02,app-srv-03,app-srv-04,webprint01,gtwy01</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Note: &nbsp;yes, these new VMs are still in need of having their OSes configured -- host name, static IP, etc. &nbsp;This can be handled via an OS Customization Spec -- just create one and specify it as a value to the </span><span class="c0">-OSCustomizationSpec</span><span>&nbsp;parameter of </span><span class="c0">New-VM</span><span>. &nbsp;As part of creating the OS Customization Spec, you can create/configure the OSCustomizationNicMapping portion, which handles the networking config of the new VM. &nbsp;That is something for the next PowerCLI lab.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Adjust VM Memory and vCPU</span></p><p class="c1"><img height="158" src="images/image02.png" width="708"></p><p class="c1"><span>Woop -- Stymie put in another ticket (332422) to have the amount of memory and number of vCPUs changed on two of his new VMs -- the app servers. &nbsp;He wants just one (1) vCPU and six (6) GB of memory for each. &nbsp;After getting Stymie&#39;s cost center to agree to pay for the additional resources, time to </span><span class="c0">Set-VM</span><span>:</span></p><p class="c1 c2"><span>## adjust vCPU/memory on these VMs</span></p><p class="c1 c2"><span>Get-VM app-srv-0[34] | Set-VM -MemoryMB 6KB -NumCpu 1 -Confirm:$false</span></p><p class="c1 c5"><span></span></p><p class="c1"><span>This command returns the info about the newly updated VMs.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Pro Tip: &nbsp;The &quot;</span><span class="c10">[34]</span><span>&quot; notation when specifying the VM names takes advantage of PowerShell wildcards, and equates to giving the names &quot;app-srv-03&quot; and &quot;app-srv-04&quot; to the </span><span class="c0">Get-VM</span><span>&nbsp;call (for more information about PowerShell wildcards, use &quot;</span><span class="c0">Get-Help -Full about_Wildcards</span><span>&quot;). &nbsp;The </span><span class="c0">Set-VM</span><span>&nbsp;call is using &quot;</span><span class="c10">6KB</span><span>&quot; for the value for the </span><span class="c0">-MemoryMB</span><span>&nbsp;parameter (which evaluates to </span><span class="c10">6144</span><span>&nbsp;so the VM has a nice, even 6GB of memory), and specifies </span><span class="c0">$false</span><span>&nbsp;for the </span><span class="c0">-Confirm</span><span>&nbsp;parameter, so that the action does not prompt for confirmation. &nbsp;The </span><span class="c0">Set-VM</span><span>&nbsp;cmdlet returns the VM objects, displaying their new sizes.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Add Disks to VMs</span></p><p class="c1"><img height="169" src="images/image00.png" width="652"></p><p class="c1"><span>Stymie is at it again -- yet another ticket (332423), as he forgot that he needs an additional 10GB disk on each of the new VMs. &nbsp;&quot;Hello? &nbsp;</span><span class="c0">New-HardDisk</span><span>? &nbsp;Yeah, we need some new hard disks...&quot;</span></p><p class="c1 c2"><span>## add a new harddisk to each of these six VMs</span></p><p class="c1 c2"><span>Get-VM dc01,dc02,app-srv-03,app-srv-04,webprint01,gtwy01 | New-HardDisk -DiskType flat -CapacityKB 10MB -StorageFormat Thin -Confirm:$false</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>And, the output of the </span><span class="c0">New-HardDisk</span><span>&nbsp;cmdlet gives the info about the newly-created hard disks. &nbsp;That &quot;</span><span class="c0">10MB</span><span>&quot; value for the </span><span class="c0">-CapacityKB</span><span>&nbsp;parameter is just to save typing out &quot;10485760&quot; to get a 10GB disk.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Interact with Guest OS via VMware Tools</span></p><p class="c1"><span class="c0">Invoke-VMScript</span><span>&nbsp;allows one to run a script &quot;in the guest OS of each of the specified virtual machines&quot;. &nbsp;It uses VMware Tools and the VIX API to do so. &nbsp;While this may not at first seem exciting, consider that this method of running scripts in the guest OS does not require that the VM be connected to the network to initiate the script. &nbsp;Say, for example, that a guest is up, but it seems that the networking may not have started up properly, and that you want to restart the network service on the guest.</span></p><p class="c1 c2"><span>## create credentials object for the guest OS</span></p><p class="c1 c2"><span>$credCentOsGuestCred = Get-Credential root</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>You will be prompted for the root credentials for this guest. &nbsp;Enter them (see top of this lab guide for passwords), and continue:</span></p><p class="c1 c2"><span>## run the script inside the guest OS of the VM</span></p><p class="c1 c2"><span>Invoke-VMScript -VM centos0 -ScriptText &quot;/etc/init.d/network restart&quot; -ScriptType bash `</span></p><p class="c1 c2"><span>-GuestCredential $credCentOsGuestCred</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>This runs the given script in the target VM, and returns the script results that are returned from the guest OS. &nbsp;The scripts can be of type PowerShell and Bat for Windows guests, and Bash for Linux-based guests.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Answer VMQuestions</span></p><p class="c1"><span>On occasion, VMs get into a state where they have a VM question to be answered. &nbsp;Maybe a VM&#39;s files were copied from another location directly to a datastore, the new VM was registered with vSphere (added to inventory), and then powered on. &nbsp;The familiar, VMQuestion &quot;This virtual machine might have been moved or copied&quot; comes up at the VM&rsquo;s first power-on:</span></p><p class="c1"><img height="225" src="images/image05.png" width="372"></p><p class="c1"><span>Another time this might happen is when a datastore fills up, and then VMs have a VMQuestion talking about, &quot;There is no more space...&quot;. &nbsp;You can get these questions with </span><span class="c0">Get-VMQuestion</span><span>:</span></p><p class="c1 c2"><span>## get all VM questions asking about &quot;moved/copied&quot;</span></p><p class="c1 c2"><span>Get-VM | Get-VMQuestion -QuestionText &quot;*have been moved or copied*&quot;</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>And, set an answer for them:</span></p><p class="c1 c2"><span>## set the answer of &quot;I copied it&quot;</span></p><p class="c1 c2"><span>Get-VM | Get-VMQuestion -QuestionText &quot;*have been moved or copied*&quot; | Set-VMQuestion -Option &quot;I copied it&quot; -Confirm:$false</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Or, for when a datastore was full and the VMs on it have the &quot;no more space&quot; question (Note: &nbsp;no VMs in this lab were put in a situation to have this question, so no demo / action is available for this scenario)</span></p><p class="c1 c2"><span>Get-VM -Datastore myDatastore0 | Get-VMQuestion -QuestionText &quot;*There is no more space*&quot; | Set-VMQuestion -Option &quot;Retry&quot; -Confirm:$false</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Get/Start/Stop Services on VMHosts</span></p><p class="c1"><img height="171" src="images/image03.png" width="589"></p><p class="c1"><span>When it is time to act on services on VMHosts, one can get there with the vSphere Client in almost no time at all: &nbsp;VMHost -&gt; Configuration Tab -&gt; Security Profile item -&gt; Properties of Services (pictured) -&gt; Select service -&gt; Options button -&gt; Service commands. &nbsp;Per host. &nbsp;Hassleville, USA. &nbsp;Or, use </span><span class="c0">Get-VMHostService</span><span>.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>The need has risen to SSH to a host and make some </span>
<span class="c0">vmkfstools</span><span>&nbsp;calls. &nbsp;To start up the &quot;SSH&quot; service (the remote Tech Support Mode):</span></p><p class="c1 c2"><span>Get-VMHost esxi01 | Get-VMHostService | ?{$_.Key -eq &quot;TSM-SSH&quot;} | Start-VMHostService -Confirm:$false</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>This uses a </span><span class="c0">Where-Object</span><span>&nbsp;clause (the </span><span class="c0">?</span><span>&nbsp;is an alias for </span><span class="c0">Where-Object</span><span>) to just get the SSH service (with Key &quot;TSM-SSH&quot;), and then pass that service on through the pipeline to </span><span class="c0">Start-VMHostService</span><span>. &nbsp;You should see a &quot;Start service&quot; task in the vSphere client, or returned by a </span><span class="c0">Get-Task</span><span>&nbsp;call.</span></p><p class="c1"><span>To visually verify that the service is now running:</span></p><p class="c1 c2"><span>Get-VMHost esxi01 | Get-VMHostService</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>The TSM-SSH service has a Running value of &quot;</span><span class="c0">true</span><span>&quot;. &nbsp;The service is running and the SSH&#39;ing can commence.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Then, when done with using SSH, to return the service to a Stopped state:</span></p><p class="c1 c2"><span>Get-VMHost esxi01 | Get-VMHostService | ?{$_.Key -eq &quot;TSM-SSH&quot;} | Stop-VMHostService -Confirm:$false</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>And, again, to visually verify that the service is now stopped:</span></p><p class="c1 c2"><span>Get-VMHost esxi01 | Get-VMHostService</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Oh, and what if a teammate forgot to stop the TSM-SSH service after the last time they needed it, and the defined standard for the team is to have the service stopped in general? &nbsp;Just get all instances of the service that are running and stop them:</span></p><p class="c1 c2"><span>Get-VMHost | Get-VMHostService | ?{$_.Key -eq &quot;TSM-SSH&quot;} | ?{$_.Running} | Stop-VMHostService -Confirm:$false</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>(we did not leave any other such services running in this lab environment)</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Changing VMHosts&rsquo; root Password</span></p><p class="c1"><span>When the time comes to change the root password on VMHosts, the time is here to use </span><span class="c0">Get- / Set-VMHostAccount</span><span>.</span></p><p class="c1 c2"><span>## current root password, to be changed</span></p><p class="c1 c2"><span>$strOldRootPassword = &quot;vmware#1&quot;</span></p><p class="c1 c2"><span>## new root password to set</span></p><p class="c1 c2"><span>$strNewRootPassword = &quot;vmware#2&quot;</span></p><p class="c5 c1 c2"><span></span></p><p class="c1 c2"><span>$arrHostsWithErrors = @()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## Create &quot;error report&quot; array</span></p><p class="c5 c1 c2"><span></span></p><p class="c1 c2"><span>Get-VMHost | ForEach-Object {</span></p><p class="c1 c2"><span>&nbsp; &nbsp; $oConnectionTmp = Connect-VIServer -Server $_.Name -User root -Password $strOldRootPassword</span></p><p class="c1 c2"><span>&nbsp; &nbsp; $objVMHostAccount = $null</span></p><p class="c1 c2"><span>&nbsp; &nbsp; $objVMHostAccount = Set-VMHostAccount -Server $_.Name -UserAccount (Get-VMHostAccount -Server $_.Name -User root) -Password $strNewRootPassword</span></p><p class="c1 c2"><span>&nbsp; &nbsp; if (($objVMHostAccount -eq $null) -or ($objVMHostAccount.GetType().Name -ne &quot;HostUserAccountImpl&quot;)) {$arrHostsWithErrors += $_.Name}</span></p><p class="c1 c2"><span>&nbsp; &nbsp; Disconnect-VIServer -Server $_.Name -Confirm:$false</span></p><p class="c1 c2"><span>} ## end foreach-object</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>This gets all VMHost using the existing VI Server connection to the vCenter server, and then for each one:</span></p><ol class="c7" start="1"><li class="c3 c1 c2"><span>connects to VMHost directly with </span><span class="c0">Connect-VIServer</span><span>, using the existing local root credentials</span></li><li class="c3 c1 c2"><span>uses </span><span class="c0">Set-VMHostAccount</span><span>&nbsp;to try to update the password for the user &quot;root&quot;</span></li><li class="c3 c1 c2"><span>if </span><span class="c0">Set-VMHostAccount</span><span>&nbsp;fails (and an object of type </span><span class="c0">HostUserAccountImpl</span><span>&nbsp;is not returned), adds the current host name to the array of hosts on which the password change encountered problems, for later review</span></li><li class="c3 c1 c2"><span>disconnects from the VMHost</span></li></ol><p class="c5 c1"><span></span></p><p class="c1"><span>You can verify that you can connect to one of the VMHosts with the new password:</span></p><p class="c1 c2"><span>Connect-VIServer esxi01</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>This should prompt for credentials -- enter &quot;root&quot; and the new password set in the previous step. &nbsp;Once connected, you can display the value for the automatic variable &quot;</span><span class="c0">$global:DefaultVIServers</span><span>&quot;, or update the PowerShell window&#39;s title bar by calling the function &quot;</span><span class="c0">Update-VNTitleBar</span><span>&quot;, as defined at the start of the lab.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Then, disconnect the direct host connection:</span></p><p class="c1 c2"><span>Disconnect-VIServer esxi01 -Confirm:$false</span></p><p class="c1 c2"><span>Update-VNTitleBar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## update the title bar to show the currently connected VI server info</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Get/Set Advanced VMHost Settings</span></p><p class="c1"><img height="169" src="images/image07.png" width="733"></p><p class="c1"><span>Current versions of VMHosts have quite a few advanced configuration items that can be set -- about 850-880 right now. &nbsp;The use of these configuration items might be, say, to tweak an installation, or to be used when advised by VMware Support so as to work around an issue. &nbsp;We need, for example, to set the number of rotated logs kept for &ldquo;hostd&rdquo; to 21, per our standard.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>First, to get the current values:</span></p><p class="c1 c2"><span>## get the advanced settings for hostd syslog logger<br>Get-VMHost | %{$strVMHostName = $_.Name; Get-VMHostAdvancedConfiguration -VMHost $strVMHostName -Name Syslog.loggers.hostd.rotate} | Select @{n=&quot;VMHost&quot;; e={$strVMHostName}}, @{n=&quot;SyslogHostdRotate&quot;; e={$_[&quot;Syslog.loggers.hostd.rotate&quot;]}}</span></p><p class="c5 c1 c2"><span></span></p><p class="c1"><span>This displays the current value for the &quot;Syslog.loggers.hostd.rotate&quot; advanced host setting. &nbsp;Ok -- now to set the values to the desired &quot;21&quot;:</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get-VMHost | Set-VMHostAdvancedConfiguration -Name Syslog.loggers.hostd.rotate -Value 21</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>The updated configuration values are returned upon success. &nbsp;You will notice the &quot;Update option values&quot; tasks in Recent Tasks in the vSphere client, or the &quot;UpdateOptions&quot; tasks returned from </span><span class="c0">Get-Task</span><span>. &nbsp;Note: &nbsp;one can also update multiple advanced configuration settings by passing a hashtable of name/value pairs to update to the </span><span class="c0">Set-VMHostAdvancedConfiguration</span><span>&nbsp;cmdlet using the </span><span class="c0">-NameValue</span><span>&nbsp;parameter.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Now, to display the updated (current) values per the hosts, run the first snippet of code. &nbsp;All changed!</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Get/Set VM ExtraConfig Settings</span></p><p class="c1"><span>There are those sometimes handy, sometimes necessary Configuration Parameters available on VMs.</span></p><p class="c1"><img height="275" src="images/image10.png" width="608"></p><p class="c1"><span>On occasion, an admin might come across a seemingly juicy config parameter, or VMware support requests the addition of a parameter. &nbsp;Or, the VM owners want copy/paste access from the MKS console screen. &nbsp;But, &quot;starting with vSphere 4.1, the Copy and Paste options are, by default, disabled for security reasons&quot;. &nbsp;Hmm.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Well, we talked to InfoSec, and they gave us the go ahead on enabling copy/paste via guest consoles. &nbsp;But, now we have x-thousand VMs to configure this, and it is one of these handy configuration parameters. &nbsp;Better have a look at the API / interweb, and see how to reconfigure a VM with the desired configuration parameters.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Looks like a couple of configuration parameters are involved: &nbsp;&quot;isolation.tools.copy.enable&quot; and &quot;isolation.tools.paste.enable&quot;. &nbsp;Ah, here we are:</span></p><p class="c1 c2"><span>## set copy/paste Isolation values for a VM; change requires VM power-cycle to take effect</span></p><p class="c1 c2"><span>## initially based on code at http://poshcode.org/1475</span></p><p class="c1 c2"><span>$strVMName = &quot;web-srv-02&quot; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## VM to config</span></p><p class="c5 c1 c2"><span></span></p><p class="c1 c2"><span>## key that enables/disables copy-to-clipboard</span></p><p class="c1 c2"><span>$strCopyEnable_key = &quot;isolation.tools.copy.enable&quot;</span></p><p class="c1 c2"><span>## key that enables/disables paste-from-clipboard</span></p><p class="c1 c2"><span>$strPasteEnable_key = &quot;isolation.tools.paste.enable&quot;</span></p><p class="c5 c1 c2"><span></span></p><p class="c1 c2"><span>## string value (not boolean) for enabling/disabling copy/paste (doing both as same here)</span></p><p class="c1 c2"><span>$strCopyPasteEnable_value = &quot;true&quot;</span></p><p class="c5 c1 c2"><span></span></p><p class="c1 c2"><span>## get the .NET View object for the VM</span></p><p class="c1 c2"><span>$viewVMToReconfig = Get-View -Property Name, Config.ExtraConfig -ViewType VirtualMachine -Filter @{&quot;Name&quot; = $strVMName}</span></p><p class="c1 c2"><span>## check the current values for the isolation settings</span></p><p class="c1 c2"><span>$viewVMToReconfig.Config.ExtraConfig | ?{$_.Key -like &quot;*isolation*&quot;}</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>This should have returned the current values for those two config items (or no return at all, if the values are not set, and the defaults are in effect).</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Well, let&#39;s go ahead and set those values to &quot;true&quot;:</span></p><p class="c1 c2"><span>## setup the VirtualMachineConfigSpec object</span></p><p class="c1 c2"><span>$oVMConfigSpec = New-Object VMware.Vim.VirtualMachineConfigSpec</span></p><p class="c1 c2"><span>$strCopyEnable_key,$strPasteEnable_key | %{ &nbsp; &nbsp;## create a couple new OptionValue objects in the configSpec ExtraConfig</span></p><p class="c1 c2"><span>&nbsp; &nbsp; $oVMConfigSpec.ExtraConfig += New-Object VMware.Vim.OptionValue -Property @{&quot;key&quot; = $_; &quot;value&quot; = $strCopyPasteEnable_value}</span></p><p class="c1 c2"><span>} ## end foreach-object</span></p><p class="c5 c1 c2"><span></span></p><p class="c1 c2"><span>## reconfig the VM w/ the new config</span></p><p class="c1 c2"><span>$viewVMToReconfig.ReconfigVM($oVMConfigSpec) &nbsp; &nbsp;## synchronously</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>This utilizes the </span><span class="c0">ReconfigVM()</span><span>&nbsp;method of a VirtualMachine .NET View object. &nbsp;It first creates a </span><span class="c0">VirtualMachineConfigSpec</span><span>&nbsp;object, used as an argument to said method, and then sets a couple of </span><span class="c0">OptionValue</span><span>&nbsp;objects for the </span><span class="c0">ExtraConfig</span><span>&nbsp;property of the configspec. &nbsp;Then, time to </span><span class="c0">ReconfigVM()</span><span>. &nbsp;Afterwards, the two lines below update the given property of the .NET View object, and then writes out the new current values:</span></p><p class="c1 c2"><span>## update the .NET View data, then display the new values added</span></p><p class="c1 c2"><span>$viewVMToReconfig.UpdateViewData(&quot;Config.ExtraConfig&quot;)</span></p><p class="c1 c2"><span>$viewVMToReconfig.Config.ExtraConfig | ?{$_.Key -like &quot;*isolation*&quot;}</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Looks like this machine is ready for copying and pasting! &nbsp;Well, almost -- these changes, which become .vmx file entries, still require a power-cycle of the VM to take effect. &nbsp;Boo for that, but hopefully that changes in the future.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>The .NET View object and the </span><span class="c0">Get-View</span><span>&nbsp;cmdlet are discussed further a bit later.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><h2 class="c1"><a name="h.6t9fmhdl2o0r"></a><img height="20" src="images/image01.png" width="23"><span>Module 3: &nbsp;Filtering Information</span></h2><p class="c1"><span>In the first section about Info Gathering above, the reporting was generally for all items in the vCenter inventory. &nbsp;There are times to focus in on particular subsets of items based on their inventory location, or based on given properties/attributes. &nbsp;Besides using parameters like </span><span class="c0">-Location</span><span>&nbsp;and </span><span class="c0">-SearchRoot</span><span>&nbsp;when available on cmdlets, using </span><span class="c0">Where-Object</span><span>&nbsp;is a great way to focus in on particular items. &nbsp;For example, VMs with a given version of VMware Tools, or VMs with Tools that are installed but not running, or only VMHosts whose build number are less than a given level. &nbsp;Now for some exercises in getting more refined results.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Get VMs on Older Virtual Hardware</span></p><p class="c1"><img height="90" src="images/image12.png" width="368"></p><p class="c1"><span>Initech support teams are ready to update the virtual hardware on their VMs, but want info about which ones need it, so as to open their detailed change management tickets.</span></p><p class="c1 c2"><span>## get all VMs and their hardware version, as before</span></p><p class="c1 c2"><span>Get-VM | Select Name,Version</span></p><p class="c5 c1 c2"><span></span></p><p class="c1 c2"><span>## just get VMs whose hardware version are not &quot;v8&quot;</span></p><p class="c1 c2"><span>Get-VM | Where-Object {$_.Version -ne &quot;v8&quot;} | Select Name,Version</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>The previous two items gets the info about VMs in inventory.</span></p><p class="c1 c2"><span>## get info about VMs _and_ templates with older vHardware</span></p><p class="c1 c2"><span>Get-View -ViewType VirtualMachine -Property Name, Config.Version | Select Name,@{n=&quot;HdwVersion&quot;; e={$_.Config.Version}} | Where-Object {$_.HdwVersion -ne &quot;vmx-08&quot;}</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>This third snippet includes templates as written, which is handy for letting the support teams know about the older templates as well.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Get VMs with Installed Tools Not Running</span></p><p class="c1"><img height="128" src="images/image11.png" width="369"></p><p class="c1"><span>Commonly, people want to get the Tools status for VMs.</span></p><p class="c5 c1"><span></span></p><p class="c1 c2"><span>## get VMs and their Tools status</span></p><p class="c1 c2"><span>Get-VM | Select Name, @{n=&quot;ToolsRunningStatus&quot;; e={$_.ExtensionData.Guest.ToolsStatus}}</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>But, the current task force is focused on just powered-on VMs with Tools not installed. &nbsp;Get that info for them:</span></p><p class="c1 c2"><span>## get VMs that are powered on whose Tools status is of &quot;toolsNotInstalled&quot;</span></p><p class="c1 c2"><span>Get-VM | ?{$_.PowerState -eq &quot;PoweredOn&quot;} | Select Name, PowerState, @{n=&quot;ToolsRunningStatus&quot;; e={$_.ExtensionData.Guest.ToolsStatus}} | ?{$_.ToolsRunningStatus -eq &quot;toolsNotInstalled&quot;}</span></p><p><span><BR /></span></p><p class="c1"><span>The </span><span class="c0">.ToolsStatus</span><span>&nbsp;property can be a value in the </span><span class="c0">VMware.Vim.VirtualMachineToolsStatus</span><span>&nbsp;enumeration: &nbsp;toolsNotInstalled, toolsNotRunning, toolsOk, toolsOld. &nbsp;So, the value of &quot;toolsNotInstalled&quot; -- pretty clear. &nbsp;The </span><span class="c0">Where-Object</span><span>&nbsp;at the end of the statement gets only VMs with Tools not installed.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Aside: &nbsp;the &quot;ToolsStatus&quot; property has been deprecated, and will go away in some future version of the API. &nbsp;VMware advises people to use the properties </span><span class="c0">toolsVersionStatus2</span><span>&nbsp;and </span><span class="c0">toolsRunningStatus</span><span>&nbsp;for vSphere version 5 environments. &nbsp;But, the </span><span class="c0">toolsVersionStatus2</span><span>&nbsp;property is only available in version 5, so using </span><span class="c0">ToolsStatus</span><span>&nbsp;for existing/remaining version 4 environments is the way to go.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">ExtensionData, Get-View</span></p><p class="c1"><span>Now for the aforementioned discussion of the </span><span class="c0">.ExtensionData</span><span>&nbsp;property of objects that standard PowerCLI cmdlets return, and the relationship to objects that </span><span class="c0">Get-View</span><span>&nbsp;returns. &nbsp;The </span><span class="c0">.ExtensionData</span><span>&nbsp;property gives access to the vCenter server-side object (the .NET View object on which actions are taken by the vSphere API). &nbsp;The .NET View object </span><span class="c14">is</span><span>&nbsp;the inventory object, instead of just an object returned to a PowerShell session with some information about the inventory object. &nbsp;This .NET View object is what the PowerCLI cmdlet </span><span class="c0">Get-View</span><span>&nbsp;returns. &nbsp;It is far more rich than the PowerShell/PowerCLI object returned by the other standard PowerCLI cmdlets (</span><span class="c0">Get-VM</span><span>, </span><span class="c0">Get-VMHost</span><span>, </span><span class="c0">Get-Datastore</span><span>, etc.).</span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c0">Get-View</span><span>&nbsp;returns the .NET View objects for hosts (of type &quot;</span><span class="c0">VMware.Vim.HostSystem</span><span>&quot;), VMs (&quot;</span><span class="c0">VMware.Vim.VirtualMachine</span><span>&quot;), datastores (&quot;</span><span class="c0">VMware.Vim.Datastore</span><span>&quot;), and so on. &nbsp;It is also used when needing to do other, advanced things, like deal with vCenter sessions, a license manager, alarm and event managers, and the like.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>To illustrate the relationship between the </span><span class="c0">.ExtensionData</span><span>&nbsp;property of the &quot;</span><span class="c0">VirtualMachineImpl</span><span>&quot; object that </span><span class="c0">Get-VM</span><span>&nbsp;returns and the whole &quot;</span><span class="c0">VMware.Vim.VirtualMachine</span><span>&quot; object returned by </span><span class="c0">Get-View</span><span>, consider getting Tools status, once again:</span></p><p class="c1 c2"><span>## Get-VM way from previous example</span></p><p class="c1 c2"><span>Get-VM | Select Name, @{n=&quot;ToolsRunningStatus&quot;; e={$_.ExtensionData.Guest.ToolsStatus}}</span></p><p class="c5 c1"><span></span></p><p class="c1 c2"><span>## Get-View way</span></p><p class="c1 c2"><span>Get-View -ViewType VirtualMachine | Select Name, @{n=&quot;ToolsRunningStatus&quot;; e={$_.Guest.ToolsStatus}}</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Notice the first way has to access the .NET View object via the </span><span class="c0">.ExtensionData</span><span>&nbsp;property, whereas the second way already has the .NET View object, so the calculated property in the </span><span class="c0">Select-Object</span><span>&nbsp;statement just accesses the </span><span class="c0">.Guest.ToolsStatus</span><span>&nbsp;property directly.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>While this can provide extra confusion, and can cause the code to be a bit (or considerably) more complex, it also opens many possibilities (optimizations / speed / depth of data / API-based operations). &nbsp;You probably noticed the speed difference (if not, check again). &nbsp;Now imagine if the environment contained a few hundred or thousand VMs.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">VM Counts by OS Version</span></p><p class="c1"><span>On the occasion that someone asks for a list of VM counts tallied by guest OS version, the standard PowerShell cmdlet </span><span class="c0">Group-Object</span><span>&nbsp;comes in quite handy. &nbsp;One could export all guest OS info to a spreadsheet and use another program to total up the counts, or do some additional coding to make a data structure to hold counts of OS versions, but </span><span class="c0">Group-Object</span><span>&nbsp;makes this a simple task:</span></p><p class="c1 c2"><span>## get VM counts by configured OS version</span></p><p class="c1 c2"><span>Get-VM | Select-Object @{n=&quot;ConfigdGuestFullName&quot;; e={$_.ExtensionData.Config.GuestFullName}} | Group-Object -NoElement ConfigdGuestFullName | Sort-Object Name | Format-Table -AutoSize</span></p><p class="c5 c1"><span></span></p><p class="c1 c2"><span>## get the same info, but via Get-View</span></p><p class="c1 c2"><span>Get-View -ViewType VirtualMachine -Property Config.GuestFullName -Filter @{&quot;Config.Template&quot; = &quot;false&quot;} &nbsp;| Select-Object @{n=&quot;ConfigdGuestFullName&quot;; e={$_.Config.GuestFullName}} | Group-Object -NoElement ConfigdGuestFullName | Sort-Object Name | Format-Table -AutoSize</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Another example of using </span><span class="c0">Get-VM</span><span>&nbsp;vs. </span><span class="c0">Get-View</span><span>. &nbsp;The second way is a bit more lengthy. &nbsp;Both ways return the same info. &nbsp;But the </span><span class="c0">Get-View</span><span>&nbsp;way is faster -- about seven (7) times faster, even in this small environment!</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Along with </span><span class="c0">Group-Object</span><span>, these use </span><span class="c0">Sort-Object</span><span>&nbsp;to -- you guessed it -- sort the objects returned. &nbsp;It also uses </span><span class="c0">Format-Table</span><span>&nbsp;with the </span><span class="c0">-AutoSize</span><span>&nbsp;parameter so as to not truncate any column info returned. &nbsp;Most often, dealing with / returning just objects helps facilitate further manipulation of the objects as the need arises (instead of having a formatted table of strings with which no more exciting pipeline activities will take place), but </span><span class="c0">Format-Table</span><span>&nbsp;does have its place.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Find VM by NIC MAC Address</span></p><p class="c1"><span>Say, now, that the InfoSec department has determined that a machine is sending malicious traffic, and they have gotten with the Networking crew to find out the source MAC address of the devious machine. &nbsp;Next stop: &nbsp;the virtualization team&#39;s area to find out what VM has a NIC with that MAC address.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>A </span><span class="c0">VirtualMachine</span><span>&nbsp;.NET View object has the VM&#39;s info, including info about the VM&#39;s configured virtual hardware devices--SCSI controllers, NICs, virtual disks, VM Video Cards, network adapters, etc. &nbsp;So, in this instance, it is just a matter of filtering all VMs&#39; virtual NICs to find the machine with the NIC with the given MAC address.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>The </span><span class="c0">VirtualMachine</span><span>&nbsp;object holds the virtual hardware device info at </span><span class="c0">.Config.Hardware.Device</span><span>. &nbsp;By checking these devices that are of type </span><span class="c0">VirtualEthernetCard</span><span>&nbsp;and that have a value for the &quot;</span><span class="c0">MacAddress</span><span>&quot; property that matches the one from InfoSec, the VM is found:</span></p><p class="c1 c2"><span>## find VM by MAC addr -- as discussed by Matt at vNugglets.com</span></p><p class="c1 c2"><span>$strMacToFind = &quot;00:50:56:36:66:F9&quot;</span></p><p class="c1 c2"><span>## return the .NET View object(s) for the VM(s) with the NIC w/ the given MAC</span></p><p class="c1 c2"><span>Get-View -Viewtype VirtualMachine -Property Name, Config.Hardware.Device | `</span></p><p class="c1 c2"><span>&nbsp; &nbsp;?{$_.Config.Hardware.Device | ?{($_ -is [VMware.Vim.VirtualEthernetCard]) `</span></p><p class="c1 c2"><span>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-and ($_.MacAddress -eq $strMacToFind)}}</span></p><p class="c5 c1"><span></span></p><p class="c1 c2"><span>## or, just some summary info about the VM: &nbsp;VM name and MAC address(es)</span></p><p class="c1 c2"><span>$strMacToFind = &quot;00:50:56:36:66:F9&quot;</span></p><p class="c1 c2"><span>Get-View -Viewtype VirtualMachine -Property Name, Config.Hardware.Device | ?{$_.Config.Hardware.Device | `</span></p><p class="c1 c2"><span>&nbsp; &nbsp;?{($_ -is [VMware.Vim.VirtualEthernetCard]) -and ($_.MacAddress -eq $strMacToFind)}} | `</span></p><p class="c1 c2"><span>&nbsp; &nbsp;Select name, @{n=&quot;MAC(s)&quot;; e={($_.Config.Hardware.Device | ?{($_ -is [VMware.Vim.VirtualEthernetCard])} | %{$_.MacAddress}) -join &quot;,&quot;}}</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Both items above use the </span><span class="c0">.Config.Hardware.Device</span><span>&nbsp;property of the </span><span class="c0">VirtualMachine</span><span>&nbsp;.NET View objects and then a </span><span class="c0">Where-Object</span><span>&nbsp;clause to get just the </span><span class="c0">VirtualEthernetCard</span><span>&nbsp;devices, and such devices whose </span><span class="c0">MacAddress</span><span>&nbsp;property matches the address in question. &nbsp;The first portion returns the .NET View object of the virtual machine(s) with the given MAC address. &nbsp;The second part employs a </span><span class="c0">Select-Object</span><span>&nbsp;statement to return just the VM name(s) and the corresponding MAC addresses. &nbsp;Here you go, InfoSec, the machine with that MAC address -- now go get &#39;em.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Duplicate MAC Address -- Find the VMs</span></p><p class="c1"><span>Sometimes the ol&#39; duplicate MAC address problem rears its head, whether a VM was brought in from another environment and just happened to have a MAC address that matched that of a VM in the new environment, or someone manually set a NIC&#39;s MAC address without verifying its uniqueness. &nbsp;However it happened, networking does not like it. &nbsp;So, let us check all MAC addresses on VMs&#39; NICs in the environment, and see if we have any duplicates.</span></p><p class="c1 c2"><span>## find VMs that correspond to duplicate MAC addresses -- as discussed by Matt at vNugglets.com</span></p><p class="c1 c2"><span>## create a collection of custom PSObjects with VM/MACAddress info</span></p><p class="c1 c2"><span>$colDevMacAddrInfo = `</span></p><p class="c1 c2"><span>Get-View -ViewType VirtualMachine -Property Name,Config.Hardware.Device -Filter @{&quot;Config.Template&quot; = &quot;False&quot;} | %{</span></p><p class="c1 c2"><span>&nbsp; &nbsp;$strVMName = $_.Name</span></p><p class="c1 c2"><span>&nbsp; &nbsp;$_.Config.Hardware.Device | Where-Object {$_ -is [VMware.Vim.VirtualEthernetCard]} | %{</span></p><p class="c1 c2"><span>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New-Object -Type PSObject -Property @{VMName = $strVMName; MacAddr = $_.MacAddress}</span></p><p class="c1 c2"><span>&nbsp; &nbsp;} ## end foreach-object</span></p><p class="c1 c2"><span>} ## end foreach-object</span></p><p class="c5 c1 c2"><span></span></p><p class="c1 c2"><span>## check if all of the MAC addresses are unique? (returns true/false)</span></p><p class="c1 c2"><span>($colDevMacAddrInfo | Select-Object -unique MacAddr).Count -eq $colDevMacAddrInfo.Count</span></p><p class="c5 c1 c2"><span></span></p><p class="c1 c2"><span>## get the non-unique MAC addresses, returning objects with the count of the duplicates, the duplicate MAC, and the VM names that have the duplicate MAC</span></p><p class="c1 c2"><span>$colDevMacAddrInfo | Group-Object MacAddr | Where-Object {$_.count -gt 1} | Select-Object Count,@{n=&quot;DuplicateMAC&quot;; e={$_.Name}},@{n=&quot;VMNames&quot;; e={($_.Group | %{$_.VMName}) -join &quot;,&quot;}}</span></p><p class="c5 c1 c2"><span></span></p><p class="c1"><span>In a fashion similar to the Find VM by NIC MAC Address task above, we get the VMs&#39; NICs&#39; MAC addresses. &nbsp;This time, we store that info in a custom PSObject (as created by </span><span class="c0">New-Object</span><span>). &nbsp;Then, utilizing the </span><span class="c0">-Unique</span><span>&nbsp;parameter to </span><span class="c0">Select-Object</span><span>, we can find if the number of unique MAC addresses matches the total number of MAC addresses. &nbsp;If so, no duplicates.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>If not, the last portion employs </span><span class="c0">Group-Object</span><span>&nbsp;and a </span><span class="c0">Where-Object</span><span>&nbsp;statement to find MAC addresses that occur more than one time. &nbsp;It should list out any VMs that share a duplicate MAC address, along with the MAC address. &nbsp;It is just that easy -- and pretty quick, too.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Find a VM When vCenter is Down</span></p><p class="c1"><span>Sometimes, vCenter goes down. &nbsp;Whether the OS fails, or some vCenter service or a dependent service is stopped, it can make standard operations a bit of a hassle. &nbsp;Consider an instance when someone needs to get on the console of a particular VM for troubleshooting, but since vCenter is down, the identity of the VMHost on which said VM resides is unknown.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Well, since the names of the VMHosts are generally known (people tend to keep an inventory of some sort -- in a DB or a spreadsheet or a txt file -- something), and PowerCLI can connect to multiple VI servers at one, finding a VM&#39;s whereabouts without vCenter is almost trivial. &nbsp;It is just a matter of connecting to all VMHosts directly with Connect-VIServer, and then finding the desired VM:</span></p><p class="c1 c2"><span>## disconnect from vCenter server &quot;vcenter&quot;, as it is supposedly down for this example</span></p><p class="c1 c2"><span>Disconnect-VIServer * -Confirm:$false</span></p><p class="c1 c2"><span>## make sure the PowerCLI config is set to connect to multiple VI Servers</span></p><p class="c1 c2"><span>Set-PowerCLIConfiguration -DefaultVIServerMode Multiple -Confirm:$false<br>## get credentials for hosts (assumes common creds)<br>$credVMHostRoot = Get-Credential root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## prompts for password</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Enter the VMHost root password (that was CHANGED in prior exercise of setting VMHost passwords -- use the new password) when prompted, then:</span></p><p class="c1 c2"><span>## make array VMHost names; could be from txt file</span><span>&nbsp;or some other &quot;data source&quot;<br>$arrVMHostNames = &quot;esxi01&quot;,&quot;esxi02&quot;<br>## connect to all of the hosts<br>Connect-VIServer -Server $arrVMHostNames -Credential $credVMHostRoot</span></p><p class="c1 c2"><span>## update the PowerShell window title bar to show all connected VMHost names</span></p><p class="c1 c2"><span>Update-VNTitleBar</span></p><p class="c1 c2"><span>## get the VM and display its name and the VMHost on which it resides<br>Get-VM centos0 | select Name, VMHost</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>This takes the manually-defined array of the two ESXi hosts in this lab environment, connects to both, does a </span><span class="c0">Get-VM</span><span>&nbsp;for the given VM, and displays the VMHost info for the VM. &nbsp;Usually an environment would have more VMHosts, and so the array of hosts would likely be made by using </span><span class="c0">Import-Csv</span><span>&nbsp;to read in from a CSV or </span><span class="c0">Get-Content</span><span>&nbsp;to get a list of VMHost names from a txt file.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>At this point, someone with rights can connect directly to the given VMHost with the vSphere client and launch the MKS console so that anxious customer Bobby can connect and take actions on his VM. &nbsp;This example is also helpful for a situation where the vCenter VM is on the same infrastructure that it manages. &nbsp;Admins need to know on what host the failed vCenter server is running so as to get to it, troubleshoot/fix it, and get it back in working order (if a virtualization team was so inclined to run their vCenter server in this manner).</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span>That is the last exercise in this lab, you made it.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><h2 class="c1"><a name="h.g0pzptkcr4p6"></a><img height="20" src="images/image01.png" width="23"><span>Some Additional PowerCLI/PowerShell Info</span></h2><p class="c1"><span class="c4">Easy PowerCLI Optimization</span></p><p class="c1"><span>You may have noticed that the first call to retrieve info/objects after </span><span class="c0">Connect-VIServer</span><span>&nbsp;takes a fair amount longer than subsequent calls. &nbsp;For example, the first </span><span class="c0">Get-VMHost</span><span>&nbsp;call can take five- to ten times as long as subsequent calls with the same cmdlet. &nbsp;This has to do with &quot;the fact that the .NET framework compiles the underlying code on first use&quot;.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>The </span><span class="c11"><a class="c12" href="http://blogs.vmware.com/vipowershell/">official PowerCLI blog</a></span><span>&nbsp;(</span><span class="c11"><a class="c12" href="http://blogs.vmware.com/vipowershell/">http://blogs.vmware.com/vipowershell/</a></span><span>)</span><span>&nbsp;has a </span><span class="c11"><a class="c12" href="http://blogs.vmware.com/vipowershell/2011/06/how-to-speed-up-the-execution-of-the-first-powercli-cmdlet.html">post</a></span><span>&nbsp;about this, with the way to take care of the first-call slowness (involving some simple commands to pre-compile some of said code). &nbsp;Several other posts exist, such as the first follow-up post that is found at </span><span class="c11"><a class="c12" href="http://vnugglets.com/2011/11/speed-up-first-powercli-5-cmdlet.html">http://</a></span><span class="c11"><a class="c12" href="http://vnugglets.com/2011/11/speed-up-first-powercli-5-cmdlet.html">vnugglets.c</a></span><span class="c11"><a class="c12" href="http://vnugglets.com/2011/11/speed-up-first-powercli-5-cmdlet.html">om/2011/11/speed-up-first-powercli-5-cmdlet.html</a></span><span>. &nbsp;Every time you are in a fresh new PowerCLI session, you will be glad that you took the time to follow the easy steps discussed in these posts.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">PowerCLI Inventory and Datastore Providers, and PSDrives</span></p><p class="c1"><span>PowerCLI has a couple of &quot;providers&quot; for accessing inventory items and datastore items. &nbsp;From the Windows PowerShell help for </span><span class="c0">Get-PSProvider</span><span>, &quot;Windows PowerShell providers let you access a variety of data stores as though they were file system drives. &nbsp;For information about Windows PowerShell providers, see </span><span class="c0">about_Providers</span><span>.&quot;</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>The VMware vSphere PowerCLI User&#39;s Guide, vSphere PowerCLI 5.0.1 (available at vmware.com, and installed locally by default with PowerCLI) discusses these providers on pages 12-13. &nbsp;When you connect to a VI server with </span><span class="c0">Connect-VIServer</span><span>, the cmdlet builds four (4) PSDrives. &nbsp;It makes two default inventory PSDrives, &quot;vis:\&quot; and &quot;vi:\&quot;, and it makes two default datastore drives, &quot;vmstores:\&quot; and &quot;vmstore:\&quot;.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>The singular-named PSDrives here correspond to the inventory and datastores of the last-connected VI server, and the plural-named PSDrives (vis:\, vmstores:\) correspond to the inventory and datastores of all connected VI servers in the current PowerCLI session. &nbsp;These can be handy for searching datastores for files, copying items from datastores to disk local to the PowerCLI session and vice versa (via </span><span class="c0">Copy-DatastoreItem</span><span>), acting on inventory items based on their inventory &quot;location&quot; on the PSDrive, and so on.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>To see these PSDrives, you can issue a standard PowerShell </span><span class="c0">Get-PSDrive</span><span>&nbsp;call. &nbsp;And, to traverse them, you can &quot;</span><span class="c0">cd</span><span>&quot; (&quot;</span><span class="c0">Set-Location</span><span>&quot;) right into them, get directory listings, etc. &nbsp;Experimenting with these PSDrives will help grow your understanding of their uses.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Resource/Speed Considerations</span></p><p class="c1"><span>As witnessed by the countless versions of PowerShell scripts available on the web to do given tasks, many ways exist to achieve a goal. &nbsp;Not all of them, however, get to that goal at the same rate. &nbsp;A few considerations for maximizing speed and minimizing resource consumption by scripts:</span></p><ol class="c7" start="1"><li class="c3 c1 c2"><span>use the pipeline as possible</span></li></ol><ol class="c6" start="1"><li class="c3 c1 c9"><span>when acting on a group of items, get them and then pass them on through the pipeline (versus getting them, storing them in a variable, and then accessing them on the next line via that new variable)</span></li></ol><ol class="c7" start="2"><li class="c3 c1 c2"><span>for storing light info, use hash-tables as data structures</span></li></ol><ol class="c6" start="1"><li class="c9 c3 c1"><span>not to contradict the previous point of utilizing the pipeline, this is not to say to store everything in a hash table!</span></li><li class="c9 c3 c1"><span>good if there are some name/value pairs that are needed for displaying info in a script (VM and description, VMHost and version, things for which multiple </span><span class="c0">Get-VM</span><span>&nbsp;calls or </span><span class="c0">Get-VMHost</span><span>&nbsp;calls would greatly slow down the script)</span></li><li class="c9 c3 c1"><span>might be common sense, but sometimes when scripts are spackled together, the author does not take care to optimize as necessary/possible</span></li></ol><ol class="c7" start="3"><li class="c3 c1 c2"><span>use </span><span class="c0">Get-View</span><span>&nbsp;when it makes sense, especially as the size of the environment grows</span></li></ol><ol class="c6" start="1"><li class="c9 c3 c1"><span>there is usually an additional up-front time cost in writing a script with </span><span class="c0">Get-View</span><span>&nbsp;versus using standard PowerCLI </span><span class="c0">Get-*</span><span>&nbsp;cmdlets, but through the use of filters and of specifying exactly which properties to retrieve (only those required for the particular situation, of course), great speed gains can be had -- like speeding up scripts 10-, 20-, 30-times, or more! &nbsp;Yes, really.</span></li><li class="c9 c3 c1"><span>filtering and selective property retrieval, in conjunction with using the pipeline instead of storing everything in variables, also helps avoid the never fun &quot;</span><span class="c0">System.OutOfMemoryException</span><span>&quot; exception when the session takes too much memory (again, this is magnified in larger environments)</span></li></ol><p class="c1"><span>Many other optimization/speed tips exist on the web, but one of the main things is to be mindful of the speed of the code as you write it!</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Code Editing, Script Debugging</span></p><p class="c1"><span>Notepad to write your PowerShell code? &nbsp;It will get the job done. &nbsp;But, many editors are available that offer syntax highlighting, from free ones like Notepad++ to inexpensive ones like Textpad, and on to more expensive editing applications. &nbsp;This feature helps with code legibility through the use of colors and whatnot (which might seem &quot;frilly&quot; if you have not used it), but this greatly increases productivity.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>And, there are debuggers available, like the free PowerShell ISE that [generally] comes installed with PowerShell (depending on your OS), and the free-and-powerful PowerGUI Script Editor from Quest (at powergui.org), and the for-purchase Sapien PrimalScript. &nbsp;If you have not dealt with a debugger -- it allows you to inspect code, variables, output, etc., and to pause code execution and walk through it step-by-step. &nbsp;A debugger is invaluable as you take on new coding challenges, dig deeper into objects, follow execution flow, and so on.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Echoing out variable values every-so-often can do for quick and dirty manual debugging, but when you get into a serious scripting situation, reach for a debugger.</span></p><p class="c5 c1"><span></span></p><p class="c5 c1"><span></span></p><p class="c1"><span class="c4">Credits / Sources</span></p><p class="c1"><span>For building the lab environment you have Brian Wuchner to thank. &nbsp;He built the infrastructure, the client piece (VMware View-based), and the initial version of the vApps used as the basis of the individual lab environments.</span></p><p class="c5 c1"><span></span></p><p class="c1"><span>Some of the code snippets here cite their source, like </span><span class="c11"><a class="c12" href="http://poshcode.org">poshcode.org</a></span><span>&nbsp;and </span><span class="c11"><a class="c12" href="http://vnugglets.com">vNugglets.com</a></span><span>. &nbsp;Most other snippets are from the archives and depths of the experiences of the </span><span class="c11"><a class="c12" href="http://vnugglets.com">vNugglets.com</a></span><span>&nbsp;authors, Allen and Matt, who created this PowerCLI lab.</span></p></body></html>